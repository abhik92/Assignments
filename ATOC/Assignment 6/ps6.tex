\documentclass[12pt]{exam}
\printanswers
\usepackage{amsmath,amssymb,complexity}
\begin{document}
\hrule
\vspace{3mm}
\noindent 
{\sf CS6014 : Advanced Theory of Computation  \hfill Karthik Abinav S}
\vspace{3mm}\\
\noindent 
{\sf Problem Set \#6 }
\vspace{3mm}
\hrule

\begin{questions}

\question[10] Oracle Queries.
\begin{parts}
\part Argue that $\P^\P = \P$. Why does not the same argument work for $\NP$ and give $\NP^{\NP} = \NP$?
\part If $\NP = \co\NP$, argue that $\PH = \Sigma_1^p$.
\end{parts}
\begin{solution}
 $\P^\P \subseteq P $ \newline
 Let $L \in \P^\P$ . There exists an oracle TM $N$ such that, it runs in polynomial time and has access to a language in $P$ as an oracle. This
 can be simulated by deterministic polynomial time machine $M$ without the oracle as follows : \newline
 
 $M$ runs on the input in the same way as $N$. Except whenever $N$ makes query to the oracle to check if $x \in K$ where $K$ is the oracle, $M$ runs
 the machine corresponding to the oracle language on $x$ and gets the answer. It then proceeds in the similar way as the machine $N$. Since the oracle is a 
 language in $\P$, the simulation of the query to oracle takes deterministic polynomial time. Hence , $M$ runs in polynomial time.
 
 $\P \subseteq \P^\P$ \newline
 This containment is trivially true, since the machine accepting $\P$ need not use the oracle and hence belongs to $\P^\P$ \newline
 
 From above two containments, $\P^\P = \P$ \newline
 
 The above argument wont work for $\NP$ because, when the oracle gives the answer as no, the same thing cannot be determined by simulating a 
 $\NP$ machine in polynomial time. Since , the time for a non deterministic machine is defined as the length of the shortest accepting path. Hence,the rejecting
 paths in the non deterministic tree may not be of polynomial length. \newline
 
 This can be shown using induction on $i$ of $\Sigma_{i}^{P}$ .\newline
 Base case. $i$ = 2. \newline
 we have to show $\NP^\NP = \NP$.
 The reverse containment is trivially true. To show the forward containment, we can simulate the queries on the oracle by simulating the two non deterministic
 machines corresponding to $L$(say $M$) and $\overline{L}$(say $N$) . There exists a non deterministic polynomial time machine for $\overline{L}$ because $\NP$ = $\co\NP$. \newline
 Whenever the original machine made a query to oracle, simulate both the non deterministic machine in time sharing fashion. If $M$ accepts, interpret as a yes answer by
 the oracle and continue calculation as the original machine. If $N$ accepts, interpret as a no answer by the oracle and continue calculation as the original machine.
 Since, both $M$ and $N$ accepts in poylnomial time, this new machine also runs in polynomial time. Hence, $\Sigma_{2}^{P}$ = $\Sigma_{1}^{P}$. \newline
 
 Let for some $k > 2$, $\Sigma_{k}^{P} = \Sigma_{1}^{P}$.\newline
 $\Sigma_{k+1}^{P}$ is language which can be accepted in $\NP$ time given an oracle to $\Sigma_{k}^{P}$. Since, from induction hypothesis, $\Sigma_{k}^{P}$
  = $\Sigma_{1}^{P}$, this can be accepted by a machine in $\NP$ time which has oracle access to $\NP$. Similar to the above case, let $M$ be a machine
  which accepts the language corresponding to $L \in \NP$ and $\overline{L} \in \co\NP$ . Now, the oracle query can be replaced by simulating both the machines
  in a time sharing manner. If $M$ accepts, interpret as a yes answer from oracle. If $N$ accepts, interpret as a no answer from oracle. Then continue
  computation normally as the oracle machine from there. Since, both $M$ and $N$ accepts in polynomial time, hence the entire simulation can be done in $\NP$ time.
  Therefore, $\Sigma_{k+1}^{P}$ = $\Sigma_{1}^{P}$.
 
 
 
\end{solution}


\question[10]
\begin{parts}
\part Reading Assignment : Read the proof (Section 3.4, Theorem 3.21, Page 93)  of the claim : $\DTIME(2^{O(s(n))} \subseteq ASPACE(s(n))$. Determine an upper bound on the number of children for any universal configuration in the alternating Turing machine produced in the construction.
\part Conclude that $AL = \P$. Show that all $\CFL$s are in $\P$ by giving an alternating Turing machine running in $\log$ space for checking membership. (Assume that the $\CFL$ is given at the input in the $CNF$ form.).
\end{parts}

\question[10]
DeÔ¨Åne the language:
\[ \textrm{\sc ShortestPath} = {(G, k, s, t)| \textrm{ the shortest path from $s$ to $t$ in $G$ has length $k$} } \]
\begin{parts}
\part[5] Prove that {\sc ShortestPath} is in $\NL$.
\part[5] Prove that {\sc ShortestPath} is in $\L$ if and only if $\L = \NL$.
\end{parts}

\question[15]
An undirected graph is bipartite if its nodes can be divided into two sets such that all edges go from a node in one set to a node in the other set. Show that a graph is bipartite
if and only if it does not contain a cycle that contains an odd number of nodes. Let 
\[ \textrm{\sc Bipartite} =
\{ G \mid G \textrm{ is a bipartite graph } \} \] 
Show that {\sc Bipartite} is in $\NL$. (Hint : Use Immerman-Szelepsinyi theorem !).

\question[25]
We define the product of two $n \times n$ Boolean matrices $A$ and $B$ as another $n \times n$ Boolean
matrix $C$ such that $C_{ij} = \bigvee_{k=1}^n (A_{ik} \land B_{kj})$.
\begin{parts}
\part[5] Show that boolean matrix multiplication can be done in logarithmic space.
\part[5] Using repeated squaring, argue that $A^p$ can be computed in space $O(\log n \log p)$.
\part[5] Show that if $A$ is the adjacency matrix of a graph, then $(A_{ij}^k = 1$ if and only if there
is a path of length at most $k$ from the vertex $i$ to vertex $j$ and is $0$ otherwise.
\part[5] Use the above to give an alternative proof that $\NL \subseteq \DSPACE(\log^2 n)$. We originally proved it using Savitch's theorem.
\end{parts}

\end{questions}

%Add your answer like this.
%\begin{solution}
%
%\end{solution}

\end{document}
