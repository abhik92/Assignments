\documentclass[a4paper,12pt]{report}
\usepackage[utf8x]{inputenc}
\addtolength{\oddsidemargin}{-.875in}
	\addtolength{\evensidemargin}{-.875in}
	\addtolength{\textwidth}{1.75in}

	\addtolength{\topmargin}{-.875in}
	\addtolength{\textheight}{1.75in}

% Title Page
\title{\textbf{Operating Systems Lab - CS3510}}
\author{\textit{Abhiram Ravi, Karthik Abinav}}


\begin{document}
\maketitle

\begin{abstract}
This is a documentation of our progress in the Operating Systems lab in the fall semester(2012-13) under \textit{ Prof V. Kamakoti}
\end{abstract}
\begin{section}{The Basics}
 The first part of lab is divided into four parts :
\begin{itemize}
 \item Segmentation
\item Interrupt and Exception Handling
\item Task Switching
\item Paging
\end{itemize}
Every group is given an \textit{Intel Atom Processor} - powered board, a bootable USB Stick with the GDB software, and a connector cable to 
connect the intel board to the host machine. The gdb software installed on the host machine takes care of any interaction that is necessary 
with the atom board. Once the atom board is booted using the USB Stick, a connection is established to the host machine by running 
the following commands on the terminal with \textit{root permissions }
\begin{verbatim}
  $ gdb 
 /* Enter the following commands in the gdb command line */
  $ set debug remote 0
  $ set remotebaud 38400
  $ target remote /dev/ttyS0
\end{verbatim}
This establishes the required connection. In case of problems, reboot the atom board and make sure the cable is 
properly connected. In the worst case, try restarting the host machine.

Now we describe how to compile the assignment programs and load them onto the atom board. All code related to these assignments are written 
in \textit{.s} files and are compiled using NASM. To compile the programs, the following commands are executed :
\begin{verbatim}
  /* gdbkama_prot & prot_test.ld are scripts given to us to automate compilation */
  $ ./gdbkama_prot code 
  /* where code.s is the program */
\end{verbatim}
Once the compilation is complete, a \textit{code.out} file is created. This file must be loaded onto the atom board.
To do this, we now return to our gdb command line and execute 
\begin{verbatim}
  $ load code.out
\end{verbatim}
  Once the loading is complete, the program is automatically executed on the atom machine\footnote{In case of repeated segmentation
faults (SIGSEGV) try loading the file twice}. Breakpoints are already set in the code template. The program is paused by the gdb upon loading.
To continue execution of the program enter 'c' in the gdb command line. If the code executed succesfully, a SIGTRAP is received. 
In order to view the register and memory state of the system, the following commands can be executed on the gdb command line
\begin{verbatim}
  /* Gives the state of the registers at any point of time */
  $ info reg 
  /* Viewing N bytes of data in memory starting from address XXXX */
  $ x/Nx XXXX
\end{verbatim}
The above commands are helpful during debugging.
 




\end{section}

\begin{section}{Assignment 1}
  \textbf {Aim }

\begin{itemize}
 \item To learn the concepts related to segmentation.
\item To set up the Global Descriptor Table
\item To understand the LGDT command, the working of segment registers, code \textit{align}ment and to revisit NASM
\end{itemize}
  \textbf {Summary} \newline
In this assignment we had to write a C code that does matrix multiplication on two matrices A (10 x 20) and B (20 x 30),
and output the answer in hexadecimal. The answer C was loaded onto the data segment of our NASM code. So were the matrices A and B. 
A matrix multiplication routine was then implemented in NASM, and the output generated was compared with the output generated by 
the C code(i.e with the values that were loaded into memory). \newline\newline
  \textbf {Implementation Details} \newline
The implementation of Matrix Multiplication in NASM was overlayed on a pre-written template \textit{prot\_start.s}

//TODO
\end{section}



\begin{section}{Assignment 3}
 \begin{verbatim}
  Task Switching
 \end{verbatim}
\textbf{Problem Statement} \newline\newline
There are four tasks that need to be implemented in this assignment. Each task has a data segment, a stack segment, a TSS descriptor entry in the GDT and a TSS.
The following checkpoints need to be reached.
\begin{itemize}
 \item Setup the GDT with all the code, data and stack segments defined. Refer Page 76 of the manual. There should be five code, 
data and stack segments to account for the four privilege levels and the exception handler.

\item Load the LTR with the offset of the first Task State Segment descriptor in the GDT. \textit{Note} : The LTR must contain the offset of the 
TSS descriptor of the process that is currently being executed.
\item The context switch can be performed using \verb jmp \verb 0xADDR:junk  where ADDR is the offset of the TSS descriptor from the start
of the GDT, for the process that we want to switch to. It also makes sure that the Task Register is loaded with the offset of the new TSS 
descriptor specified.
\end{itemize}
  \textbf{Notes}\newline\newline
\textbf{First Implementation}\newline
\textit{25th September, 2012}\newline
In the first implementation we tried to make a simple modification to the template code. The LTR is by default 0x60 , which is the 
descriptor of the default TSS. We just added the following lines to the code
\begin{verbatim}
  mov eax, 0xcafedead
  jmp 0x70:0x0
  jmp exit1
\end{verbatim}
0x70 contains the offset of the TSS descriptor of TSS[0.1]. We observed that the current state (i.e eax) is saved successfully 
in the default TSS. In order to verify whether the context switch is complete, we need to describe a code segment for the new process ([0.1])
in the GDT, set the EIP value in the TSS[0.1] to 0, and execute some code at the start of the code segment described to verify the completeness
of the switch.\newline\newline
  \textbf{Verifying the Task Switch}\newline
\textit{8th October, 2012}\newline
We realized that we need to put \verb jmp \verb 0x71  instead of \verb jmp \verb 0x70  because of the requester privilege level. There are three bits in the
segment selector(which is used while jumping to) which are always redundant because the offset of the TSS descriptor from the start of GDT is always a multiple of
8. Because of this, these three bits are used for another purpose, one bit of which is to represent if the descriptor refers to the GDT/LDT,
and the remaining two bits to represent the privilege level of the callee(RPL).

The current task has a DPL and a CPL(descriptor privilege level/ code segment privilege level). The task that we want to 
switch to also has its own CPL and DPL. In such a case, the requestor privilege level (RPL(0)) \newline
$ RPL(0) \leq min\{ DPL(1), CPL(1) \} $

\begin{verbatim}
 How is the context switching done? 
\end{verbatim}
\newline
\textbf{Step 1} : First, the \verb jmp \verb 0xADDR:junk  call is made. Now, convert ADDR to binary, replace the last three bits with 000,
and then go to the location that is offset by this value from the GDT. Now this location contains the TSS descriptor of the 
task that you want to call. \newline \newline
\textbf{Step 2} : Before actually popping the values of the registers from the TSS, the state of the current task is stored in its TSS. 
Hardware does this because it knows the current TSS from the value in Task Register (LTR would have initially been done) \newline \newline
\textbf{Step 3} : Now the values in the TSS segment of the new task are loaded into the registers, and location of TSS descriptor
is updated in the Task Register (LTR is done automatically). Now the system knows that it is ready 
to start executing the code of the new task. In order to know where to start executing from, it now looks up the code segment descriptor
of this task in the GDT. How does the system know where this code segment descriptor is? In the TSS which is loaded, there is an 
entry for CS register. Basically, it goes to an offset of CS:EIP (of the TSS) in the GDT. Note that in the CS value which is put in
the TSS, we must also take care of the RPL\footnote{For example, instead of 0x10, it should be 0x11, if the privilege level 
of the location in the GDT we want to go to, is PL1}. Now that we have gone to the code segment descriptor in the GDT, 
it finds out the start address of the code of the task. It starts execution from here. A value can be loaded into memory to 
verify the completeness of the switch.    \newline \newline
\textbf{Step 4} : Once the code of the second task is done executing, we use the \verb iret  to return back to the previous task.
The explanation for this is as follows. There is a location in every TSS which contains a link to the previous task. 
While filling the TSS manually, we leave this field blank(0x0). But whenever a task switch is done, the hardware automatically
fills in the value. So after the \verb iretd  command, hardware looks up this value in the TSS and returns to the first task.
The first task continues its execution after the instruction that 
initiated the task switch (the jmp command).

\end{section}

\end{document}          
