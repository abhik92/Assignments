\documentclass[a4paper,10pt]{report}
\usepackage[utf8x]{inputenc}

% Title Page
\title{Operating Systems Lab - CS3510}
\author{Abhiram Ravi, Karthik Abinav}


\begin{document}
\maketitle

\begin{abstract}
This is a documentation of our progress in the Operating Systems lab in the fall semester(2012-13) under \textit{ Prof V. Kamakoti}
\end{abstract}
\begin{section}{The Basics}
 The first part of lab is divided into four parts :
\begin{itemize}
 \item Segmentation
\item Interrupt and Exception Handling
\item Task Switching
\item Paging
\end{itemize}
Every group is given an \textit{Intel Atom Processor} - powered board, a bootable USB Stick with the GDB software, and a connector cable to 
connect the intel board to the host machine. The gdb software installed on the host machine takes care of any interaction that is necessary 
with the atom board. Once the atom board is booted using the USB Stick, a connection is established to the host machine by running 
the following commands on the terminal with \textit{root permissions }
\begin{verbatim}
  $ gdb 
 /* Enter the following commands in the gdb command line */
  $ set debug remote 0
  $ set remotebaud 38400
  $ target remote /dev/ttyS0
\end{verbatim}
This establishes the required connection. In case of problems, reboot the atom board and make sure the cable is 
properly connected. In the worst case, try restarting the host machine.

Now we describe how to compile the assignment programs and load them onto the atom board. All code related to these assignments are written 
in \textit{.s} files and are compiled using NASM. To compile the programs, the following commands are executed :
\begin{verbatim}
  /* gdbkama_prot & prot_test.ld are scripts given to us to automate compilation */
  $ ./gdbkama_prot code 
  /* where code.s is the program */
\end{verbatim}
Once the compilation is complete, a \textit{code.out} file is created. This file must be loaded onto the atom board.
To do this, we now return to our gdb command line and execute 
\begin{verbatim}
  $ load code.out
\end{verbatim}
  Once the loading is complete, the program is automatically executed on the atom machine\footnote{In case of repeated segmentation
faults (SIGSEGV) try loading the file twice}. Breakpoints are already set in the code template. The program is paused by the gdb upon loading.
To continue execution of the program enter 'c' in the gdb command line. If the code executed succesfully, a SIGTRAP is received. 
In order to view the register and memory state of the system, the following commands can be executed on the gdb command line
\begin{verbatim}
  /* Gives the state of the registers at any point of time */
  $ info reg 
  /* Viewing N bytes of data in memory starting from address XXXX */
  $ x/Nx XXXX
\end{verbatim}
 




\end{section}

\begin{section}{Assignment 1}
 \begin{verbatim}
  Matrix Multiplication in NASM
 \end{verbatim}
  \textbf {Summary} \newline
In this assignment we had to write a C code that does matrix multiplication on two matrices A (10 x 20) and B (20 x 30),
and output the answer in hexadecimal. The answer C was loaded onto the data segment of our NASM code. So were the matrices A and B. 
A matrix multiplication routine was then implemented in NASM, and the output generated was compared with the output generated by 
the C code(i.e with the values that were loaded into memory). \newline\newline
  \textbf {Implementation Details} \newline
The implementation of Matrix Multiplication in NASM was overlayed on a pre-written template \textit{prot\_start.s}
\end{section}



\begin{section}{Assignment 3}
 \begin{verbatim}
  Task Switching: TODO List
 \end{verbatim}
  \begin{itemize}
   \item Setup the GDT properly with all the code, data and stack segments defined. Refer Page 76 of the manual.
   \item Load the Task Register with the address in the GDT where the description of the Task State Segments begin.
   \item 
  \end{itemize}


\end{section}

\end{document}          
